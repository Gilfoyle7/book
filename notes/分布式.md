+ #### 一致性哈希

  + 场景描述

    ​	假设有三台缓存图片的服务器，编号为0，1，2，那么为了将图片能够数量均匀的缓存到服务器上，我们可以通过哈希算法计算图片的哈希值，并对哈希值取模，从而知道这张图片应该缓存到哪台服务器上，也就是：

    ​	`服务器编号 = hash(图片名称) % N`

    ​	其中N在这个例子中是3，也就是服务器的数量。这个场景存在一个问题，当服务器数量发生变化时，那么大量缓存将会在一定时间内失效，当应用无法从缓存中获取数据时，则会向后端服务器请求数据，此时很有可能出现缓存雪崩的情况。

  + 问题解决

    ​	为了解决上述问题，一致性哈希算法出现了。一致性哈希算法同样是取模，但是是对2^32取模。这里有一个概念叫hash环，是指使用2的32次方个点组成的圆环。这里需要对服务器和图片都进行计算

    ​	`服务器在hash环的位置 = hash(服务器的IP地址) % 2^32`

    ​	`图片在hash环的位置 = hash(服务器的IP地址) % 2^32`

    ​	与之前算法的不同之处在于这里对服务器也计算了hash值，得到位置之后，图片应当缓存的服务器位置便是从图片的位置开始，沿顺时针方向遇到的第一个服务器。

    + 优点

    ​	使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有的缓存都会失效。

  + 缺点

    ​	可能会出现**偏斜**情况，服务器在hash环的分布过于集中，导致大部分数据缓存在某个单独的服务器上。

    ​	**虚拟节点**可以解决偏斜问题。虚拟节点是实际节点的复制品，一个实际节点可以对应多个虚拟节点。使用虚拟节点让环上的节点更多更均匀，缓存被均匀分布的概率就越大。**虚拟节点的另外一个用处，是当某个机器因为扛不住崩溃了，可以防止环上的下个机器需要扛住2倍的流量**


+ #### 一致性哈希

  + 场景描述

    ​	假设有三台缓存图片的服务器，编号为0，1，2，那么为了将图片能够数量均匀的缓存到服务器上，我们可以通过哈希算法计算图片的哈希值，并对哈希值取模，从而知道这张图片应该缓存到哪台服务器上，也就是：

    ​	`服务器编号 = hash(图片名称) % N`

    ​	其中N在这个例子中是3，也就是服务器的数量。这个场景存在一个问题，当服务器数量发生变化时，那么大量缓存将会在一定时间内失效，当应用无法从缓存中获取数据时，则会向后端服务器请求数据，此时很有可能出现缓存雪崩的情况。

  + 问题解决

    ​	为了解决上述问题，一致性哈希算法出现了。一致性哈希算法同样是取模，但是是对2^32取模。这里有一个概念叫hash环，是指使用2的32次方个点组成的圆环。这里需要对服务器和图片都进行计算

    ​	`服务器在hash环的位置 = hash(服务器的IP地址) % 2^32`

    ​	`图片在hash环的位置 = hash(服务器的IP地址) % 2^32`

    ​	与之前算法的不同之处在于这里对服务器也计算了hash值，得到位置之后，图片应当缓存的服务器位置便是从图片的位置开始，沿顺时针方向遇到的第一个服务器。

    + 优点

    ​	使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有的缓存都会失效。

  + 缺点

    ​	可能会出现**偏斜**情况，服务器在hash环的分布过于集中，导致大部分数据缓存在某个单独的服务器上。

    ​	**虚拟节点**可以解决偏斜问题。虚拟节点是实际节点的复制品，一个实际节点可以对应多个虚拟节点。使用虚拟节点让环上的节点更多更均匀，缓存被均匀分布的概率就越大。**虚拟节点的另外一个用处，是当某个机器因为扛不住崩溃了，可以防止环上的下个机器需要扛住2倍的流量**
  
+ #### QPS

  术语说明：
  QPS = req/sec = 请求数/秒

  【QPS计算PV和机器的方式】

  QPS统计方式 [一般使用 http_load 进行统计]
  QPS = 总请求数 / ( 进程总数 *   请求时间 )
  QPS: 单个进程每秒请求服务器的成功次数

  单台服务器每天PV计算
  公式1：每天总PV = QPS * 3600 * 6
  公式2：每天总PV = QPS * 3600 * 8

  服务器计算
  服务器数量 =   ceil( 每天总PV / 单台服务器每天总PV )

  【峰值QPS和机器计算公式】

  原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间
  公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)
  机器：峰值时间每秒QPS / 单台机器的QPS   = 需要的机器

  问：每天300w PV 的在单台机器上，这台机器需要多少QPS？
  答：( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)

  问：如果一台机器的QPS是58，需要几台机器来支持？
  答：139 / 58 = 3

